---
timestamp: 'Tue Oct 14 2025 01:17:52 GMT-0400 (Eastern Daylight Time)'
content_id: b85b8eeb90a2bed408bd48ff2c07317f462ddab87403f70be417d9e04aa68f53
---

# file: src/concepts/Friending/FriendingConcept.ts

```typescript
import { Collection, Db } from "npm:mongodb";
import { Empty, ID } from "../../utils/types.ts"; // Assuming utils are in parent directory
import { freshID } from "../../utils/database.ts"; // Assuming utils are in parent directory

/**
 * Concept: Friending (User)
 *
 * @purpose allow users to add each other as friends to share information with
 * @principle If user A sends a friend request to user B, and user B accepts the request, then A and B become friends. After becoming friends, either party has the option to remove the other as a friend. Alternatively, user B also has the option to deny the request from user A should they wish to.
 */

// Declare collection prefix, use concept name
const PREFIX = "Friending" + ".";

// Generic type of this concept
type User = ID;

/**
 * State: a set of Friendships
 * @state a set of Friendships with a set of Users (length 2)
 */
interface FriendshipDoc {
  _id: ID; // Unique ID for the friendship
  users: [User, User]; // Store users in a sorted array to ensure uniqueness regardless of order
}

/**
 * State: a set of FriendRequests
 * @state a set of FriendRequests with a sender User and a receiver User
 */
interface FriendRequestDoc {
  _id: ID; // Unique ID for the request
  sender: User;
  receiver: User;
}

export default class FriendingConcept {
  private friendships: Collection<FriendshipDoc>;
  private friendRequests: Collection<FriendRequestDoc>;

  constructor(private readonly db: Db) {
    this.friendships = this.db.collection(PREFIX + "friendships");
    this.friendRequests = this.db.collection(PREFIX + "friendRequests");
  }

  /**
   * Action: sendRequest
   * @requires sender is not the receiver, friend request from sender to receiver or vice versa does not already exist, friendship does not already exist
   * @effects creates a new friend request from sender to receiver
   */
  async sendRequest(
    { sender, receiver }: { sender: User; receiver: User },
  ): Promise<Empty | { error: string }> {
    if (sender === receiver) {
      return { error: "Cannot send friend request to self." };
    }

    // Check for existing pending request (sender -> receiver or receiver -> sender)
    const existingRequest = await this.friendRequests.findOne({
      $or: [
        { sender: sender, receiver: receiver },
        { sender: receiver, receiver: sender },
      ],
    });
    if (existingRequest) {
      return { error: "Friend request already exists or is pending." };
    }

    // Check for existing friendship
    const sortedUsers: [User, User] = [sender, receiver].sort() as [User, User];
    const existingFriendship = await this.friendships.findOne({
      users: sortedUsers,
    });
    if (existingFriendship) {
      return { error: "Users are already friends." };
    }

    // Create new friend request
    const newRequest: FriendRequestDoc = {
      _id: freshID(),
      sender,
      receiver,
    };
    await this.friendRequests.insertOne(newRequest);
    return {};
  }

  /**
   * Action: acceptRequest
   * @requires request from sender to receiver to exist
   * @effects removes friend request, records friendship between sender and user
   */
  async acceptRequest(
    { sender, receiver }: { sender: User; receiver: User },
  ): Promise<Empty | { error: string }> {
    // Find and remove the friend request
    const deleteResult = await this.friendRequests.deleteOne({
      sender: sender,
      receiver: receiver,
    });

    if (deleteResult.deletedCount === 0) {
      return { error: "Friend request not found." };
    }

    // Record the friendship
    const sortedUsers: [User, User] = [sender, receiver].sort() as [User, User];
    const newFriendship: FriendshipDoc = {
      _id: freshID(),
      users: sortedUsers,
    };
    await this.friendships.insertOne(newFriendship);
    return {};
  }

  /**
   * Action: denyRequest
   * @requires request from sender to receiver to exist
   * @effects removes friend request
   */
  async denyRequest(
    { sender, receiver }: { sender: User; receiver: User },
  ): Promise<Empty | { error: string }> {
    const deleteResult = await this.friendRequests.deleteOne({
      sender: sender,
      receiver: receiver,
    });

    if (deleteResult.deletedCount === 0) {
      return { error: "Friend request not found." };
    }

    return {};
  }

  /**
   * Action: removeFriend
   * @requires friendship between user and to_be_removed_friend must exist
   * @effects removes friendship between user and to_be_removed_friend
   */
  async removeFriend(
    { user, to_be_removed_friend }: { user: User; to_be_removed_friend: User },
  ): Promise<Empty | { error: string }> {
    const sortedUsers: [User, User] = [user, to_be_removed_friend].sort() as [
      User,
      User,
    ];

    const deleteResult = await this.friendships.deleteOne({
      users: sortedUsers,
    });

    if (deleteResult.deletedCount === 0) {
      return { error: "Friendship not found." };
    }

    return {};
  }

  /**
   * Query: _getFriends
   * Returns a list of users who are friends with the given user.
   */
  async _getFriends(
    { user }: { user: User },
  ): Promise<{ friends: User[] }> {
    const friendships = await this.friendships.find({
      users: user,
    }).toArray();

    const friends = friendships.flatMap((f) =>
      f.users.filter((u) => u !== user)
    );
    return { friends };
  }

  /**
   * Query: _getSentFriendRequests
   * Returns an array of pending friend requests sent by the given user.
   * @requires user to exist (implicitly, as it's an ID)
   * @effects returns an array of FriendRequestDoc objects where the user is the sender
   */
  async _getSentFriendRequests(
    { user }: { user: User },
  ): Promise<FriendRequestDoc[]> {
    const sentRequests = await this.friendRequests.find({ sender: user })
      .toArray();
    return sentRequests;
  }

  /**
   * Query: _getReceivedFriendRequests
   * Returns an array of pending friend requests received by the given user.
   * @requires user to exist (implicitly, as it's an ID)
   * @effects returns an array of FriendRequestDoc objects where the user is the receiver
   */
  async _getReceivedFriendRequests(
    { user }: { user: User },
  ): Promise<FriendRequestDoc[]> {
    const receivedRequests = await this.friendRequests.find({ receiver: user })
      .toArray();
    return receivedRequests;
  }
}

```
